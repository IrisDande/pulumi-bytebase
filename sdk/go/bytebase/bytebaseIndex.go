// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package bytebase

import (
	"context"
	"reflect"

	"errors"
	"github.com/IrisDande/pulumi-bytebase/sdk/go/bytebase/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type bytebaseIndex struct {
	pulumi.CustomResourceState

	// The dimensions of the vectors in the index. Defaults to 1536.
	Dimension pulumi.IntPtrOutput `pulumi:"dimension"`
	// The URL address where the index is hosted.
	Host pulumi.StringOutput `pulumi:"host"`
	// The metric used to compute the distance between vectors.
	Metric IndexMetricOutput `pulumi:"metric"`
	// The name of the bytebase index.
	Name pulumi.StringOutput `pulumi:"name"`
	// Describe how the index should be deployed.
	Spec bytebaseSpecOutput `pulumi:"spec"`
}

// NewbytebaseIndex registers a new resource with the given unique name, arguments, and options.
func NewbytebaseIndex(ctx *pulumi.Context,
	name string, args *bytebaseIndexArgs, opts ...pulumi.ResourceOption) (*bytebaseIndex, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Metric == nil {
		return nil, errors.New("invalid value for required argument 'Metric'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	if args.Spec == nil {
		return nil, errors.New("invalid value for required argument 'Spec'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource bytebaseIndex
	err := ctx.RegisterResource("bytebase:index:bytebaseIndex", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetbytebaseIndex gets an existing bytebaseIndex resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetbytebaseIndex(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *bytebaseIndexState, opts ...pulumi.ResourceOption) (*bytebaseIndex, error) {
	var resource bytebaseIndex
	err := ctx.ReadResource("bytebase:index:bytebaseIndex", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering bytebaseIndex resources.
type bytebaseIndexState struct {
}

type bytebaseIndexState struct {
}

func (bytebaseIndexState) ElementType() reflect.Type {
	return reflect.TypeOf((*bytebaseIndexState)(nil)).Elem()
}

type bytebaseIndexArgs struct {
	// The dimensions of the vectors in the index. Defaults to 1536.
	Dimension *int `pulumi:"dimension"`
	// The metric used to compute the distance between vectors.
	Metric IndexMetric `pulumi:"metric"`
	// The name of the bytebase index.
	Name string `pulumi:"name"`
	// Describe how the index should be deployed.
	Spec bytebaseSpec `pulumi:"spec"`
}

// The set of arguments for constructing a bytebaseIndex resource.
type bytebaseIndexArgs struct {
	// The dimensions of the vectors in the index. Defaults to 1536.
	Dimension pulumi.IntPtrInput
	// The metric used to compute the distance between vectors.
	Metric IndexMetricInput
	// The name of the bytebase index.
	Name pulumi.StringInput
	// Describe how the index should be deployed.
	Spec bytebaseSpecInput
}

func (bytebaseIndexArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*bytebaseIndexArgs)(nil)).Elem()
}

type bytebaseIndexInput interface {
	pulumi.Input

	TobytebaseIndexOutput() bytebaseIndexOutput
	TobytebaseIndexOutputWithContext(ctx context.Context) bytebaseIndexOutput
}

func (*bytebaseIndex) ElementType() reflect.Type {
	return reflect.TypeOf((**bytebaseIndex)(nil)).Elem()
}

func (i *bytebaseIndex) TobytebaseIndexOutput() bytebaseIndexOutput {
	return i.TobytebaseIndexOutputWithContext(context.Background())
}

func (i *bytebaseIndex) TobytebaseIndexOutputWithContext(ctx context.Context) bytebaseIndexOutput {
	return pulumi.ToOutputWithContext(ctx, i).(bytebaseIndexOutput)
}

// bytebaseIndexArrayInput is an input type that accepts bytebaseIndexArray and bytebaseIndexArrayOutput values.
// You can construct a concrete instance of `bytebaseIndexArrayInput` via:
//
//	bytebaseIndexArray{ bytebaseIndexArgs{...} }
type bytebaseIndexArrayInput interface {
	pulumi.Input

	TobytebaseIndexArrayOutput() bytebaseIndexArrayOutput
	TobytebaseIndexArrayOutputWithContext(context.Context) bytebaseIndexArrayOutput
}

type bytebaseIndexArray []bytebaseIndexInput

func (bytebaseIndexArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*bytebaseIndex)(nil)).Elem()
}

func (i bytebaseIndexArray) TobytebaseIndexArrayOutput() bytebaseIndexArrayOutput {
	return i.TobytebaseIndexArrayOutputWithContext(context.Background())
}

func (i bytebaseIndexArray) TobytebaseIndexArrayOutputWithContext(ctx context.Context) bytebaseIndexArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(bytebaseIndexArrayOutput)
}

// bytebaseIndexMapInput is an input type that accepts bytebaseIndexMap and bytebaseIndexMapOutput values.
// You can construct a concrete instance of `bytebaseIndexMapInput` via:
//
//	bytebaseIndexMap{ "key": bytebaseIndexArgs{...} }
type bytebaseIndexMapInput interface {
	pulumi.Input

	TobytebaseIndexMapOutput() bytebaseIndexMapOutput
	TobytebaseIndexMapOutputWithContext(context.Context) bytebaseIndexMapOutput
}

type bytebaseIndexMap map[string]bytebaseIndexInput

func (bytebaseIndexMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*bytebaseIndex)(nil)).Elem()
}

func (i bytebaseIndexMap) TobytebaseIndexMapOutput() bytebaseIndexMapOutput {
	return i.TobytebaseIndexMapOutputWithContext(context.Background())
}

func (i bytebaseIndexMap) TobytebaseIndexMapOutputWithContext(ctx context.Context) bytebaseIndexMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(bytebaseIndexMapOutput)
}

type bytebaseIndexOutput struct{ *pulumi.OutputState }

func (bytebaseIndexOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**bytebaseIndex)(nil)).Elem()
}

func (o bytebaseIndexOutput) TobytebaseIndexOutput() bytebaseIndexOutput {
	return o
}

func (o bytebaseIndexOutput) TobytebaseIndexOutputWithContext(ctx context.Context) bytebaseIndexOutput {
	return o
}

// The dimensions of the vectors in the index. Defaults to 1536.
func (o bytebaseIndexOutput) Dimension() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *bytebaseIndex) pulumi.IntPtrOutput { return v.Dimension }).(pulumi.IntPtrOutput)
}

// The URL address where the index is hosted.
func (o bytebaseIndexOutput) Host() pulumi.StringOutput {
	return o.ApplyT(func(v *bytebaseIndex) pulumi.StringOutput { return v.Host }).(pulumi.StringOutput)
}

// The metric used to compute the distance between vectors.
func (o bytebaseIndexOutput) Metric() IndexMetricOutput {
	return o.ApplyT(func(v *bytebaseIndex) IndexMetricOutput { return v.Metric }).(IndexMetricOutput)
}

// The name of the bytebase index.
func (o bytebaseIndexOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *bytebaseIndex) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Describe how the index should be deployed.
func (o bytebaseIndexOutput) Spec() bytebaseSpecOutput {
	return o.ApplyT(func(v *bytebaseIndex) bytebaseSpecOutput { return v.Spec }).(bytebaseSpecOutput)
}

type bytebaseIndexArrayOutput struct{ *pulumi.OutputState }

func (bytebaseIndexArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*bytebaseIndex)(nil)).Elem()
}

func (o bytebaseIndexArrayOutput) TobytebaseIndexArrayOutput() bytebaseIndexArrayOutput {
	return o
}

func (o bytebaseIndexArrayOutput) TobytebaseIndexArrayOutputWithContext(ctx context.Context) bytebaseIndexArrayOutput {
	return o
}

func (o bytebaseIndexArrayOutput) Index(i pulumi.IntInput) bytebaseIndexOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *bytebaseIndex {
		return vs[0].([]*bytebaseIndex)[vs[1].(int)]
	}).(bytebaseIndexOutput)
}

type bytebaseIndexMapOutput struct{ *pulumi.OutputState }

func (bytebaseIndexMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*bytebaseIndex)(nil)).Elem()
}

func (o bytebaseIndexMapOutput) TobytebaseIndexMapOutput() bytebaseIndexMapOutput {
	return o
}

func (o bytebaseIndexMapOutput) TobytebaseIndexMapOutputWithContext(ctx context.Context) bytebaseIndexMapOutput {
	return o
}

func (o bytebaseIndexMapOutput) MapIndex(k pulumi.StringInput) bytebaseIndexOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *bytebaseIndex {
		return vs[0].(map[string]*bytebaseIndex)[vs[1].(string)]
	}).(bytebaseIndexOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*bytebaseIndexInput)(nil)).Elem(), &bytebaseIndex{})
	pulumi.RegisterInputType(reflect.TypeOf((*bytebaseIndexArrayInput)(nil)).Elem(), bytebaseIndexArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*bytebaseIndexMapInput)(nil)).Elem(), bytebaseIndexMap{})
	pulumi.RegisterOutputType(bytebaseIndexOutput{})
	pulumi.RegisterOutputType(bytebaseIndexArrayOutput{})
	pulumi.RegisterOutputType(bytebaseIndexMapOutput{})
}
